"use strict";
{
  const typeNameMatcher = /\[object (\w+)]/;
  const $ = Symbol("[[Uint1ArrayInternal]]");
  const INTERNAL_FORMAT = Uint32Array;

  // Node or browser, either is fine

  // FIXME : remove after testing complete 
  //try { module.exports = Uint1Array; } catch( e ) { Object.assign( self, { Uint1Array } ); }

  // classes 

    class Uint1ArrayPrivates {
      constructor( publics, length ) {
        const wordSize = INTERNAL_FORMAT.BYTES_PER_ELEMENT * 8;
        const wordSizeMask = wordSize - 1;
        const wordSizeShift = msb_index( wordSize );
        const internal = new INTERNAL_FORMAT( length );
        Object.assign( this, {
          length,
          wordSize,
          wordSizeMask,
          wordSizeShift,
          internal
        });
      }
      toArray() {
        const byte_sz = ( this.length + 7 ) >> 3;
        const array = new Uint8Array( byte_sz );
        for( let i = 0; i < this.length; i++ ) {
          array[i] = this.getBit(i);
        }
        return array;
      }
      getBit( i ) {
        const word_number = i >> this.wordSizeShift;
        const word_offset = i & this.wordSizeMask;
        const word = this.internal[word_number];
        const bit = (word << word_offset) >> this.wordSize;
        return bit;
      }
      setBit( i, bit ) {
        const word_number = i >> this.wordSizeShift;
        const word_offset = i & this.wordSizeMask;
        const word = this.internal[word_number];
        word = word | ( bit << word_offset ); // make it 1 if 1, no change if 0
        word = word & ~(~bit << word_offset ); // make it 0 if 0, no change if 1
        this.internal[word_number] = word;
        return bit;

      }
    }

    class Uint1ArrayPublics {
      // Uint1Array constructor 
      
        constructor( thing ) {
          // find the constructor invocation
          const typeName = resolveTypeName( thing );
          
          // for private internal properties
          const length = thing;
          const privates = new Uint1ArrayPrivates( this, length );
          // testing
          Object.defineProperty( this, 'p', { get: () => privates } );
          Object.defineProperty( this, $, { get: () => privates } );
          console.log("pubs", this, $, privates );
          return this;
        }
      
      // Static property slots on the constructor

        static get BYTES_PER_ELEMENT() {
          return 0.125;
        }
        static get name() {
          return "Uint1Array";
        }
        static get length() {
          return 0;
        }
        static get [Symbol.species]() {
          return this;
        }

      // Static method slots on the constructor 

        static from( iterable ) {
          const temp = [];
          let length = 0;
          for( let item of iterable ) {
            const bit = toBit( item );
            temp.push( bit );
            length++;
          }
          const internal = new Uint8ClampedArray( length );
          internal.set( temp );
          return new this( internal );
        }

        static of( ...items ) {
          return this.from( items );
        }

        // Property slots on the instances

        get buffer() {
          return this[$].buffer;
        }

        get byteLength() {
          return ( this.length + 7 ) >> 3;
        }

        get byteOffset() {
          return 0;
        }

        get length() {
          return this[$].length;
        }

      // Method slots on the instance

        copyWithin( ...args ) {
          this[$].internal.copyWithin( ...args );
          return this;
        }

        entries() {
          return this[$].internal.entries();
        }

        every( ...args ) {
          return this[$].internal.every( ...args );
        }

        fill( ...args ) {
          this[$].internal.fill( ...args );
          return this;
        }

        filter( ...args ) {
          return new this( this[$].internal.filter( ...args ) );
        }

        find( ...args ) {
          return this[$].internal.find( ...args );
        }

        findIndex( ...args ) {
          return this[$].internal.findIndex( ...args );
        }

        forEach( ...args ) {
          this[$].internal.forEach( ...args );
        }

        includes( ...args ) {
          return this[$].internal.includes( ...args );
        }

        indexOf( ...args ) {
          return this[$].internal.indexOf( ...args );
        }

        join( ...args ) {
          return this[$].internal.join( ...args );
        }

        keys( ...args ) {
          return this[$].internal.keys( ...args );
        }

        lastIndexOf( ...args ) {
          return this[$].internal.lastIndexOf( ...args );
        }

        map( ...args ) {
          return new this( this[$].internal.map( ...args ) );
        }

        reduce( ...args ) {
          return this[$].internal.reduce( ...args );
        }

        reduceRight( ...args ) {
          return this[$].internal.reduceRight( ...args );
        }

        reverse( ...args ) {
          return new this( this[$].internal.reverse( ...args ) );
        }

        set( ...args ) {
          this[$].internal.set( ...args );
        }

        slice( ...args ) {
          return new this( this[$].internal.slice( ...args ) );
        }

        sort( ...args ) {
          return this[$].internal.sort( ...args );
        }

        subarray( ...args ) {
          return new this( this[$].internal.subarray( ...args ) );
        }

        values( ...args ) {
          return this[$].internal.values( ...args );
        }

        toLocaleString( ...args ) {
          return this[$].internal.toLocaleString( ...args );
        }

        toString( ...args ) {
          return this[$].internal.toString( ...args );
        }

        [Symbol.iterator]() {
          return this[$].internal[Symbol.iterator]();
        }
    }

    class Uint1Array extends Uint32Array {
      constructor( arg ) {
        super();
        const api = new Uint1ArrayPublics( arg );
        const accessorProxy = new AccessorProxy( api );
        //accessorProxy[$] = api[$];
        //console.log( api[$] )
        return accessorProxy;
        this.__proto__.__proto__ = accessorProxy;
        return this;
      }
    }

  // accessor proxy 

    function AccessorProxy( api ) {
      const privates = api[$];
      const { wordSize, wordSizeMask, wordSizeShift } = privates;
      const handler = {
        get( _, slot, surface ) {
          console.log("Get", slot );
          if ( Number.isInteger( slot ) ) {
            return privates.getBit( slot );
          } else {
            console.log("Get", slot );
            return Reflect.get( api, slot );
          }
        },
        set( _, slot, value, surface ) {
          console.log("Set", slot, value );
          if ( Number.isInteger( slot ) ) {
            const bit = toBit( value );
            return privates.setBit( slot, value );
          } else {
            console.log("Set", slot, value );
            return Reflect.set( api, slot, value );
          }
        }
      };
      const proxy = new Proxy( api, handler );
      return proxy;
    }

  // helpers
    
    function msb_index( number ) {
      let i = 0;
      while( number >>= 1 ) {
        i++;
      }
      return i;
    }

    function toBit( thing ) {
      return !! thing ? 1 : 0;
    }

    function resolveTypeName( thing ) {
      return typeNameMatcher.exec( Object.prototype.toString.call( thing ) )[1];
    }
  
  (function () {
    const x = new Uint1Array(4);
    console.log("OK", x );
    x[0] = 0;
    x[1] = 1;
    x[2] = 1;
    console.log("x", x );
    console.log( "x1", x[$].getBit(1) );
  }());

  module.exports = Uint1Array;
}
